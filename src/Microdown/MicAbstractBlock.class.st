"
I am the abstract node of the block objects generated by `MicrodownParser`.

The root of the parse tree is an instance of `MicRootBlock`.
I have a set of children, and an uplink to my parent.

See the comment of `MicrodownParser` for an overview of the algorithm used to build such a parse tree.
"
Class {
	#name : 'MicAbstractBlock',
	#superclass : 'MicElement',
	#instVars : [
		'children',
		'parser'
	],
	#category : 'Microdown-Model',
	#package : 'Microdown',
	#tag : 'Model'
}

{ #category : 'public' }
MicAbstractBlock class >> alternateBlockClassFor: line [
	"This hook supports extensions of environments. 
	we get <!slide ... and we do not create an environment but a slideBlock"
	
	^ self
]

{ #category : 'adding' }
MicAbstractBlock >> addChild: childBlock [
	"Add the argument childBlock as child of the receiver. 
	Set the parent backpointer so that childBlock parent is the receiver."
	
	childBlock basicParent: self.
	children add: childBlock
]

{ #category : 'public' }
MicAbstractBlock >> addLineAndReturnNextNode: line [
	"add line to this node. 
	Notice, the action is allowed to create new nodes in the block tree.
	Returns the node to handle next line - typically self."

	self subclassResponsibility.
	^ self
]

{ #category : 'public' }
MicAbstractBlock >> blockExtensionStarterClassFrom: line [
	"return the class of a block which can start with line, or nil if none"

	^ nil
]

{ #category : 'public' }
MicAbstractBlock >> blockStarterClassFrom: line [
	"Return the class of a block which can start with line, or nil if none.
	The principle is the following 
		- first we get a class 
		- then such class as environment are asked since they can act as factory 
		and return other classes. 
		For example <!citation does not return an environment but a MicCitationBlock"

	^ (self parser blockStarterClassFrom: line) ifNotNil: [ :c | c alternateBlockClassFor: line ]
]

{ #category : 'public' }
MicAbstractBlock >> canConsumeLine: line [
	"return if this block can consume line"

	^ self subclassResponsibility 
]

{ #category : 'adding' }
MicAbstractBlock >> children [
	^ children 
]

{ #category : 'adding' }
MicAbstractBlock >> children: aCollection [
 	children := aCollection
]

{ #category : 'public' }
MicAbstractBlock >> closeMe [
	"I'm hook for closing elements. By default do nothing."
	
	^ self
]

{ #category : 'public' }
MicAbstractBlock >> computeNestedLevel [ 

	^ 0
]

{ #category : 'properties' }
MicAbstractBlock >> hasProperty: aKey [
	"Test if the property aKey is present."
	
	^ self properties isNotNil and: [ self properties includesKey: aKey ]
]

{ #category : 'accessing' }
MicAbstractBlock >> indent [
	^ parent indent
]

{ #category : 'initialization' }
MicAbstractBlock >> initialize [
	super initialize. 
	children := OrderedCollection new.
]

{ #category : 'testing' }
MicAbstractBlock >> listItemBlockClass [
	^ MicListItemBlock
]

{ #category : 'hooks' }
MicAbstractBlock >> massageLine: aLine [
	"In some cases an element may want to massage the line such as removing leading tab. By default we delegate to the parent because environment may contain nodes such as code block and this is this nesting that will determine what should be done with the tab. In such a case the environment should remov the tabs."
	
	^ self parent massageLine: aLine
]

{ #category : 'public' }
MicAbstractBlock >> nestedLevel [ 
	"Return the nesting level of main blocks. Basically only list increases this."
	
	^ 0
]

{ #category : 'public' }
MicAbstractBlock >> newBlockFor: line parent: parentBlock [
	| newBlockClass |
	newBlockClass := self blockStarterClassFrom: line.
	newBlockClass ifNil: [ ^parentBlock ].
	^ newBlockClass new
		setParser: parser;
		parent: parentBlock;
		addLineAndReturnNextNode: line
]

{ #category : 'private' }
MicAbstractBlock >> parser [
	^ parser 
]

{ #category : 'private' }
MicAbstractBlock >> parserClass [ 
	^ MicrodownParser
]

{ #category : 'adding' }
MicAbstractBlock >> removeChild: childBlock [
	"Remove the childBlock as child of the receiver. 
	Set the parent backpointer so that childBlock parent is the receiver."

	children remove: childBlock
]

{ #category : 'replacement' }
MicAbstractBlock >> replace: aMicElement by: anotherMicElement [ 
	
	self children replaceAll: aMicElement with: anotherMicElement.
	aMicElement basicParent: nil.
	anotherMicElement basicParent: self.
]

{ #category : 'replacement' }
MicAbstractBlock >> replace: aMicElement byCollection: aCollection [ 
	
	children := children copyReplaceAll: {aMicElement} with: aCollection 
]

{ #category : 'replacement' }
MicAbstractBlock >> replaceByAll: aCollection [ 
	self parent replace: self byCollection: aCollection 
]

{ #category : 'private' }
MicAbstractBlock >> setParser: aParser [
	parser := aParser 
]

{ #category : 'accessing' }
MicAbstractBlock >> text [
	| text |
	self flag: #todo.
	"what a terrible idea we concatenate the text of children and store. 
	I could understand that we keep the text of the parser element but then we do not modify it after
	and certainly not change it."
	text := ''.
	children do: [ :each | text := text , each text ].
	^ text
]
